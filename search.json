[
  {
    "objectID": "R_C_Math.html",
    "href": "R_C_Math.html",
    "title": "Using R’s C Functions in Stan Models",
    "section": "",
    "text": "The R programming language provides robust, precise, and efficient implementations of many mathematical functions and distributions. While these can be used in Stan models by interfacing with an R session, this involves significant overhead and can result in slow sampling.\nGiven that a majority of R’s core functions and distributions are implemented in C, we can use Stan’s external C++ framework to call them directly, avoiding the need and overhead of an R session entirely."
  },
  {
    "objectID": "R_C_Math.html#motivation",
    "href": "R_C_Math.html#motivation",
    "title": "Using R’s C Functions in Stan Models",
    "section": "",
    "text": "The R programming language provides robust, precise, and efficient implementations of many mathematical functions and distributions. While these can be used in Stan models by interfacing with an R session, this involves significant overhead and can result in slow sampling.\nGiven that a majority of R’s core functions and distributions are implemented in C, we can use Stan’s external C++ framework to call them directly, avoiding the need and overhead of an R session entirely."
  },
  {
    "objectID": "R_C_Math.html#r-function-quantile-functions---log-inputs",
    "href": "R_C_Math.html#r-function-quantile-functions---log-inputs",
    "title": "Using R’s C Functions in Stan Models",
    "section": "R Function: Quantile Functions - log inputs",
    "text": "R Function: Quantile Functions - log inputs\nWhen evaluating quantile functions we often prefer to provide the input probability on the log-scale to avoid numerical issues with under- or overflow. For the present example, we will use R’s qnorm() and qt() functions to calculate the quantile function for a standard-normal distribution and a standard student-t distribution where the input probability is provided on the log scale:\nThe R signature for the qnorm() function is:\n\nqnorm(p, mean, sd, lower.tail, log.p)\n\nWhich maps directly to the underlying C implementation:\n\ndouble  qnorm(double, double, double, int, int);\n\n\nGradients\nWe will also need to calculate gradients for inputs if we are aiming to use the function with parameters in a Stan model. The gradients for quantile function, with respect to the probability parameter, are given by the reciprocal of the density, and the adjustment for inputs on the log-scale are easily given by the chain rule:\n\\[\n\\frac{\\text{d}}{\\text{d}p}F^{-1}(e^p) \\\\\n= \\frac{\\text{d}}{\\text{d}x}F^{-1}(x) \\cdot \\frac{\\text{d}}{\\text{d}p}e^p \\\\\n= \\frac{e^p}{f(F^{-1}(e^p))}\n\\]\nThis means that we can also use R’s corresponding density functions, dnorm() and dt(), to define the gradients\n\n\nStan - External C++\nTo use the density and quantile functions in our external C++, we simply include R’s math header and then define our functions as usual:\n\nheader_code &lt;- \"\n  #include &lt;stan/math.hpp&gt;\n  #include &lt;Rmath.h&gt;\n  \n  double qnorm_logp(double p, std::ostream* pstream__) {\n    return qnorm(p, 0, 1, 1, 1);\n  }\n  \n  double qt_logp(double p, double df, std::ostream* pstream__) {\n    return qt(p, df, 1, 1);\n  }\n  \n  stan::math::var qt_logp(stan::math::var p, double df, std::ostream* pstream__) {\n    return stan::math::make_callback_var(\n      qt_logp(p.val(), df, pstream__),\n      [p, df](auto& vi) mutable {\n        // Calculate gradient on log-scale for numerical stability\n        p.adj() += vi.adj() * exp(p.val() - dt(vi.val(), df, 1));\n      }\n    );\n  }\n  \n  stan::math::var qnorm_logp(stan::math::var p, std::ostream* pstream__) {\n    return stan::math::make_callback_var(\n      qnorm_logp(p.val(), pstream__),\n      [p](auto& vi) mutable {\n        // Calculate gradient on log-scale for numerical stability\n        p.adj() += vi.adj() * exp(p.val() - dnorm(vi.val(), 0, 1, 1));\n      }\n    );\n  }\n\"\n\nuser_hpp &lt;- tempfile(fileext = \".hpp\")\nwriteLines(header_code, con = user_hpp)\n\n\n\nStan - Stan Model\nWe will use the following (nonsensical) Stan model to test the values and gradients of the implementation:\n\nstan_code &lt;- \"\n  functions {\n    real qnorm_logp(real logp);\n    real qt_logp(real logp, data real df);\n  }\n  \n  data {\n    int use_normal;\n  }\n  \n  parameters {\n    real&lt;upper=0&gt; log_p;\n  }\n  \n  transformed parameters {\n    real qnorm_test = qnorm_logp(log_p);\n    real qt_test = qt_logp(log_p, 3);\n  }\n  \n  model {\n    target += use_normal ? qnorm_test : qt_test;\n  }\n\"\n\nstan_file &lt;- tempfile(fileext = \".stan\")\nwriteLines(stan_code, con = stan_file)\n\n\n\nStan - Compilation & Linking\nIn order for the Stan model to be able to use the C functions from R, we need to provide additional flags to the compilation & linking of the model. Thankfully, R has built-in functions which return these flags:\n\ncpp_options = list(\n  paste0(\"CPPFLAGS += -I\", shQuote(R.home(\"include\"))),\n  paste0(\"LDLIBS += -L\", shQuote(R.home(\"lib\")), \" -lR\")\n)\n\nWe can then pass these directly to cmdstanr, along with our model and external C++, for compilation:\n\nmod &lt;- cmdstanr::cmdstan_model(stan_file, \n                               user_header = user_hpp,\n                               stanc_options = list(\"allow-undefined\"),\n                               cpp_options = cpp_options,\n                               force_recompile = TRUE)\n\nIn file included from stan/lib/stan_math/stan/math/prim/prob/std_normal_ccdf_log.hpp:5,\n                 from stan/lib/stan_math/stan/math/prim/prob.hpp:276,\n                 from stan/lib/stan_math/stan/math/prim.hpp:18,\n                 from stan/lib/stan_math/stan/math/rev.hpp:18,\n                 from stan/lib/stan_math/stan/math.hpp:19,\n                 from C:/Users/Andrew/AppData/Local/Temp/Rtmp8snoY6/file4f7c21567bca.hpp:2,\n                 from &lt;command-line&gt;:\nstan/lib/stan_math/stan/math/prim/prob/std_normal_lccdf.hpp: In function 'stan::return_type_t&lt;T&gt; stan::math::std_normal_lccdf(const T_y&)':\nstan/lib/stan_math/stan/math/prim/prob/std_normal_lccdf.hpp:52: note: '-Wmisleading-indentation' is disabled from this point onwards, since column-tracking was disabled due to the size of the code/headers\n   52 |     } else if (y_dbl &gt; 8.25) {\n      | \n\n\nstan/lib/stan_math/stan/math/prim/prob/std_normal_lccdf.hpp:52: note: adding '-flarge-source-files' will allow for more column-tracking support, at the expense of compilation time and memory\n\n\nC\n\n\n:\\rtools44\\x86_64-w64-mingw32.static.posix\\bin/ld.exe: cannot find -lR: No such file or directory\n\n\ncollect2.exe: error: ld returned 1 exit status\n\n\nmake: *** [make/program:82: C:/Users/Andrew/AppData/Local/Temp/Rtmp8snoY6/model-4f7c6fcb1b50.exe] Error 1\n\n\nError: An error occured during compilation! See the message above for more information.\n\n\n\n\nStan - Validation\nTo test our implementation, we can fit the model for a small number of iterations and check that the calculated quantiles are consistent with those returned by qnorm() in R directly, which shows that the values match completely.\n\nfit &lt;- mod$sample(data = list(use_normal = 0), chains = 1,\n                      iter_warmup = 50, iter_sampling = 50,\n                      show_messages = FALSE,\n                      show_exceptions = FALSE)\n\nError: object 'mod' not found\n\nfit$draws(variables = c(\"log_p\", \"qnorm_test\", \"qt_test\")) |&gt;\n    posterior::mutate_variables(qnorm_true = qnorm(log_p, log.p=TRUE),\n                                qt_true = qt(log_p, df = 3, log.p=TRUE)) |&gt;\n    posterior::summarise_draws()\n\nError: object 'fit' not found\n\n\nNext, to validate the specification of gradients, we can use cmdstanr’s $diagnose() method to check that our gradient calculations match those from finite-differencing, which also shows a great match:\n\nmod$diagnose(data = list(use_normal = 1))$gradients()\n\nError: object 'mod' not found\n\nmod$diagnose(data = list(use_normal = 0))$gradients()\n\nError: object 'mod' not found"
  }
]