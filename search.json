[
  {
    "objectID": "R_In_Stan.html",
    "href": "R_In_Stan.html",
    "title": "Using R Functions in Stan Models",
    "section": "",
    "text": "A common question/request is for the ability to use R functions and packages as part of a Stan model specification. This requires two components:\n\nCalling R functions from C++\nGradients with respect to each function input\n\nWhile Stan can automatically calculate the gradients for C++ functions if they are implemented using existing functions with gradients, this cannot be extended to R functions. This means that any usage of R-based functions with parameters (i.e., not in the transformed data or generated quantities blocks) requires that a function for calculating the gradients is also implemented.\nThis document will provide a worked example for the process of using an R function in a Stan model via external C++.\nWe will be implementing the log determinant function:\n\\[\n\\log |M|\n\\]\nWhich has gradients:\n\\[\n\\frac{d}{dM} \\log |M| = \\left(M^{-1}\\right)^T\n\\]\nNote that the log determinant is already available in Stan as the log_determinant() function, which we will use to verify that the implementation is correct.",
    "crumbs": [
      "Case Studies",
      "Using R Functions in Stan Models"
    ]
  },
  {
    "objectID": "R_In_Stan.html#introduction",
    "href": "R_In_Stan.html#introduction",
    "title": "Using R Functions in Stan Models",
    "section": "",
    "text": "A common question/request is for the ability to use R functions and packages as part of a Stan model specification. This requires two components:\n\nCalling R functions from C++\nGradients with respect to each function input\n\nWhile Stan can automatically calculate the gradients for C++ functions if they are implemented using existing functions with gradients, this cannot be extended to R functions. This means that any usage of R-based functions with parameters (i.e., not in the transformed data or generated quantities blocks) requires that a function for calculating the gradients is also implemented.\nThis document will provide a worked example for the process of using an R function in a Stan model via external C++.\nWe will be implementing the log determinant function:\n\\[\n\\log |M|\n\\]\nWhich has gradients:\n\\[\n\\frac{d}{dM} \\log |M| = \\left(M^{-1}\\right)^T\n\\]\nNote that the log determinant is already available in Stan as the log_determinant() function, which we will use to verify that the implementation is correct.",
    "crumbs": [
      "Case Studies",
      "Using R Functions in Stan Models"
    ]
  },
  {
    "objectID": "R_In_Stan.html#rinside-calling-r-from-c",
    "href": "R_In_Stan.html#rinside-calling-r-from-c",
    "title": "Using R Functions in Stan Models",
    "section": "RInside: Calling R from C++",
    "text": "RInside: Calling R from C++\nThe process of interacting with R from C++ is greatly simplified by the RInside R package, which provides the C++ headers for initialising and managing an R session. The data structures that RInside uses for passing results between R and C++ are also designed for use with Rcpp and RcppEigen, which are needed for easy handling of matrix and vector types.\nHowever, a key detail that needs to be emphasised is that an R session can only be initialised once for a given program. This means that a single R session and its environment will be used for the entirety of the sampling/estimation process. Consequently, it should be considered best-practice to delete any variables/objects in the R session once they are no longer needed - otherwise you might be re-using objects/values from a previous iteration without realising.",
    "crumbs": [
      "Case Studies",
      "Using R Functions in Stan Models"
    ]
  },
  {
    "objectID": "R_In_Stan.html#c",
    "href": "R_In_Stan.html#c",
    "title": "Using R Functions in Stan Models",
    "section": "C++:",
    "text": "C++:\nNext, we need to specify the C++ for our function to use with both arithmetic and autodiff (i.e., parameters) types:\n\n/**\n * The Stan headers *must* be included before the Rcpp headers, otherwise\n * internal definitions for Eigen are ignored\n*/\n#include &lt;stan/math.hpp&gt;\n#include &lt;RInside.h&gt;\n#include &lt;RcppEigen.h&gt;\n\n// If Stan detects R headers/environment it can cause issues for compilation\n// as it assumes the code is to be used by rstan\n#ifdef USING_R\n#undef USING_R\n#endif\n\n/**\n * The RInstance object is declared 'static' so that C++ knows not to delete\n * the object and invalidate the R session until the program has finished,\n * it also ensures that the created session is specific to this program\n * to avoid accessing other sessions (or having this session accessed by other processes)\n*/\nstatic RInside RInstance;\n\ntemplate &lt;typename T, stan::require_st_arithmetic&lt;T&gt;* = nullptr&gt;\ndouble r_log_determinant(const T& m, std::ostream *pstream__) {\n  /**\n   * Passing objects to R is very simple, as the conversion from C++ -&gt; R types\n   * is automatically delegated to Rcpp or similar (e.g., RcppEigen).\n  */\n  RInstance[\"m_val\"] = m;\n\n  /**\n   * Interacting with the R session is primarily through string commands.\n   *   - The `parseEval()` method is for commands which will return an object\n   *   - The `parseEvalQ()` method is for commands with no return value/object\n   *\n   * Rcpp again handles the process of converting the returned R object to the\n   * desired C++ type. You can allow this to be handled automatically, or you\n   * can wrap the call in `Rcpp::as&lt;T&gt;()` where `T` is the desired C++ type.\n  */\n  double log_det_val = RInstance.parseEval(\"determinant(m_val, logarithm = TRUE)$modulus\");\n\n  /**\n   * Make sure to clean-up the R environment before returning!\n  */\n  RInstance.parseEvalQ(\"rm(m_val)\");\n\n  return log_det_val;\n}\n\ntemplate &lt;typename T, stan::require_st_var&lt;T&gt;* = nullptr&gt;\nstan::math::var r_log_determinant(const T& m,\n                                  std::ostream *pstream__) {\n  using stan::arena_t;\n  using stan::math::var;\n  using stan::math::value_of;\n\n  /**\n   * The parameters are moved into Stans memory arena so that their gradients\n   * can be updated in the reverse pass\n  */\n  arena_t&lt;Eigen::Matrix&lt;var, -1, -1&gt;&gt; arena_m = m;\n\n  /**\n   * The R process is exactly the same as the non-parameter version, just with\n   * the addition of calculating the gradients for the input 'm'\n  */\n  RInstance[\"m_val\"] = stan::math::value_of(arena_m);\n  double log_det_val = RInstance.parseEval(\"determinant(m_val, logarithm = TRUE)$modulus\");\n  Eigen::MatrixXd log_det_grad = RInstance.parseEval(\"t(solve(m_val))\");\n  RInstance.parseEvalQ(\"rm(m_val)\");\n\n  /**\n   * Also move the calculated gradients into the memory arena so we can access\n   * them in the reverse pass\n  */\n  arena_t&lt;Eigen::MatrixXd&gt; log_det_grad_arena = log_det_grad;\n\n  /**\n   * Initialise a new parameter with the calculated value, and specify how the\n   * gradients for the inputs should be updated in the reverse pass\n  */\n  var log_det = log_det_val;\n  stan::math::reverse_pass_callback([arena_m, log_det, log_det_grad_arena]() mutable {\n    arena_m.adj() += log_det.adj() * log_det_grad_arena;\n  });\n\n  return log_det;\n}",
    "crumbs": [
      "Case Studies",
      "Using R Functions in Stan Models"
    ]
  },
  {
    "objectID": "R_In_Stan.html#stan",
    "href": "R_In_Stan.html#stan",
    "title": "Using R Functions in Stan Models",
    "section": "Stan",
    "text": "Stan\n\nModel\nTo test that the R-implemented log_determinant() returns the same values and gradients as the built-in Stan function, we will use the following (nonsensical) model:\n\nfunctions {\n  real r_log_determinant(matrix x);\n}\ndata {\n  int&lt;lower=0&gt; N;\n  array[N] int&lt;lower=0,upper=1&gt; y;\n  int use_r;\n}\nparameters {\n  matrix[2, 2] matrix_par;\n}\ntransformed parameters {\n  real log_det;\n  log_det = use_r ? r_log_determinant(matrix_par) : log_determinant(matrix_par);\n}\nmodel {\n  y ~ bernoulli_logit(log_det);\n}\n\n\n\nCompilation\nTo use this external C++ with Stan, we need to provide the additional compilation & linker flags for compiling against R, RInside, Rcpp, and RcppEigen. Both R and these packages provide methods for extracting these flags:\n\nextra_cxxflags &lt;- c(\n  paste0(\"-I\", shQuote(R.home(\"include\"))),\n  Rcpp:::RcppCxxFlags(),\n  RcppEigen:::RcppEigenCxxFlags(),\n  RInside:::RInsideCxxFlags()\n)\n\n# R library stored in different directory on windows\nlibdir &lt;- ifelse(.Platform$OS.type == \"windows\", R.home(\"bin\"), R.home(\"lib\"))\n\nextra_ldlibs &lt;- c(\n  paste0(\"-L\", shQuote(libdir), \" -lR\"),\n  RInside:::RInsideLdFlags()\n)\n\ncpp_options &lt;- list(\n  paste0(c(\"CXXFLAGS +=\", extra_cxxflags), collapse = \" \"),\n  paste0(c(\"LDLIBS +=\", extra_ldlibs), collapse = \" \")\n)\n\nThese will then be used to compile the model and external functions:\n\nmod &lt;- cmdstanr::cmdstan_model(stan_file,\n                               user_header = user_hpp,\n                               cpp_options = cpp_options,\n                               force_recompile = TRUE)\n\n\n\nEvaluation\nTo check our implementation, weâ€™ll use the $diagnose() method to calculate the initial values and gradients for a model, and compare the results between the built-in log_determinant() and our implementation.\n\ndata &lt;- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1), use_r = 0)\n\nThe built-in returns:\n\nmod$diagnose(data = data, seed = 2023)$gradients()\n\n  param_idx     value    model finite_diff        error\n1         0  1.240610  1.06710     1.06710  4.57541e-10\n2         1  1.301600 -4.51515    -4.51515 -1.25091e-09\n3         2 -1.885300  3.11724     3.11724 -4.61351e-10\n4         3 -0.445567 -2.97116    -2.97116  1.70452e-10\n\n\nAnd our implementation:\n\ndata$use_r &lt;- 1\nmod$diagnose(data = data, seed = 2023)$gradients()\n\n  param_idx     value    model finite_diff        error\n1         0  1.240610  1.06710     1.06710  4.57541e-10\n2         1  1.301600 -4.51515    -4.51515 -1.25091e-09\n3         2 -1.885300  3.11724     3.11724 -4.61350e-10\n4         3 -0.445567 -2.97116    -2.97116  1.70450e-10\n\n\nAll looks good!",
    "crumbs": [
      "Case Studies",
      "Using R Functions in Stan Models"
    ]
  },
  {
    "objectID": "R_In_Stan.html#using-r-functions-without-analytic-gradients",
    "href": "R_In_Stan.html#using-r-functions-without-analytic-gradients",
    "title": "Using R Functions in Stan Models",
    "section": "Using R Functions without Analytic Gradients",
    "text": "Using R Functions without Analytic Gradients\nIn some cases, the analytic gradients for a given function might not always be known or easy to calculate. As a less-efficient alternative the gradients for a given function could also be computed numerically in R. For example, we could have calculated the gradients for our function using the numDeriv::grad() function:\n\nRInstance.parseEvalQ(\"detfun &lt;- function(x) { determinant(x, logarithm = TRUE)$modulus }\");\nEigen::MatrixXd log_det_grad = RInstance.parseEval(\"matrix(numDeriv::grad(detfun, m_val), nrow=nrow(m_val))\");",
    "crumbs": [
      "Case Studies",
      "Using R Functions in Stan Models"
    ]
  },
  {
    "objectID": "R_C_Math.html",
    "href": "R_C_Math.html",
    "title": "Using Râ€™s C Functions in Stan Models",
    "section": "",
    "text": "The R programming language provides robust, precise, and efficient implementations of many mathematical functions and distributions. While these can be used in Stan models by interfacing with an R session, this involves significant overhead and can result in slow sampling.\nGiven that a majority of Râ€™s core functions and distributions are implemented in C, we can use Stanâ€™s external C++ framework to call them directly, avoiding the need and overhead of an R session entirely.",
    "crumbs": [
      "Case Studies",
      "Using R's C Functions in Stan Models"
    ]
  },
  {
    "objectID": "R_C_Math.html#motivation",
    "href": "R_C_Math.html#motivation",
    "title": "Using Râ€™s C Functions in Stan Models",
    "section": "",
    "text": "The R programming language provides robust, precise, and efficient implementations of many mathematical functions and distributions. While these can be used in Stan models by interfacing with an R session, this involves significant overhead and can result in slow sampling.\nGiven that a majority of Râ€™s core functions and distributions are implemented in C, we can use Stanâ€™s external C++ framework to call them directly, avoiding the need and overhead of an R session entirely.",
    "crumbs": [
      "Case Studies",
      "Using R's C Functions in Stan Models"
    ]
  },
  {
    "objectID": "R_C_Math.html#r-function-quantile-functions---log-inputs",
    "href": "R_C_Math.html#r-function-quantile-functions---log-inputs",
    "title": "Using Râ€™s C Functions in Stan Models",
    "section": "R Function: Quantile Functions - log inputs",
    "text": "R Function: Quantile Functions - log inputs\nWhen evaluating quantile functions we often prefer to provide the input probability on the log-scale to avoid numerical issues with under- or overflow. For the present example, we will use Râ€™s qnorm() and qt() functions to calculate the quantile function for a standard-normal distribution and a standard student-t distribution where the input probability is provided on the log scale:\nThe R signature for the qnorm() function is:\n\nqnorm(p, mean, sd, lower.tail, log.p)\n\nWhich maps directly to the underlying C implementation:\n\ndouble  qnorm(double, double, double, int, int);\n\n\nGradients\nWe will also need to calculate gradients for inputs if we are aiming to use the function with parameters in a Stan model. The gradients for quantile function, with respect to the probability parameter, are given by the reciprocal of the density, and the adjustment for inputs on the log-scale are easily given by the chain rule:\n\\[\n\\frac{\\text{d}}{\\text{d}p}F^{-1}(e^p) \\\\\n= \\frac{\\text{d}}{\\text{d}x}F^{-1}(x) \\cdot \\frac{\\text{d}}{\\text{d}p}e^p \\\\\n= \\frac{e^p}{f(F^{-1}(e^p))}\n\\]\nThis means that we can also use Râ€™s corresponding density functions, dnorm() and dt(), to define the gradients\n\n\nStan - External C++\nTo use the density and quantile functions in our external C++, we simply include Râ€™s math header and then define our functions as usual:\n\n#include &lt;stan/math.hpp&gt;\n#include &lt;Rmath.h&gt;\n\ndouble qnorm_logp(double p, std::ostream* pstream__) {\n  return qnorm(p, 0, 1, 1, 1);\n}\n\ndouble qt_logp(double p, double df, std::ostream* pstream__) {\n  return qt(p, df, 1, 1);\n}\n\nstan::math::var qt_logp(stan::math::var p, double df, std::ostream* pstream__) {\n  return stan::math::make_callback_var(\n    qt_logp(p.val(), df, pstream__),\n    [p, df](auto& vi) mutable {\n      // Calculate gradient on log-scale for numerical stability\n      p.adj() += vi.adj() * exp(p.val() - dt(vi.val(), df, 1));\n    }\n  );\n}\n\nstan::math::var qnorm_logp(stan::math::var p, std::ostream* pstream__) {\n  return stan::math::make_callback_var(\n    qnorm_logp(p.val(), pstream__),\n    [p](auto& vi) mutable {\n      // Calculate gradient on log-scale for numerical stability\n      p.adj() += vi.adj() * exp(p.val() - dnorm(vi.val(), 0, 1, 1));\n    }\n  );\n}\n\n\n\nStan - Stan Model\nWe will use the following (nonsensical) Stan model to test the values and gradients of the implementation:\n\nfunctions {\n  real qnorm_logp(real logp);\n  real qt_logp(real logp, data real df);\n}\n\ndata {\n  int use_normal;\n}\n\nparameters {\n  real&lt;upper=0&gt; log_p;\n}\n\ntransformed parameters {\n  real qnorm_test = qnorm_logp(log_p);\n  real qt_test = qt_logp(log_p, 3);\n}\n\nmodel {\n  target += use_normal ? qnorm_test : qt_test;\n}\n\n\n\nStan - Compilation & Linking\nIn order for the Stan model to be able to use the C functions from R, we need to provide additional flags to the compilation & linking of the model. Thankfully, R has built-in functions which return these flags:\n\n# R library stored in different directory on windows\nlibdir &lt;- ifelse(.Platform$OS.type == \"windows\", R.home(\"bin\"), R.home(\"lib\"))\n\ncpp_options = list(\n  paste0(\"CPPFLAGS += -I\", shQuote(R.home(\"include\"))),\n  paste0(\"LDLIBS += -L\", shQuote(libdir), \" -lR\")\n)\n\nWe can then pass these directly to cmdstanr, along with our model and external C++, for compilation:\n\nmod &lt;- cmdstanr::cmdstan_model(stan_file,\n                               user_header = user_hpp,\n                               stanc_options = list(\"allow-undefined\"),\n                               cpp_options = cpp_options,\n                               force_recompile = TRUE)\n\nstanc: option '--allow-undefined' cannot be repeated\nUsage: stanc [OPTION]â€¦ [MODEL_FILE]\nTry 'stanc --help' for more information.\n\n\nmake: *** [make/program:66: /tmp/RtmpOBGpCq/model-1ff51ba16855.hpp] Error 124\n\n\nError: An error occured during compilation! See the message above for more information.\n\n\n\n\nStan - Validation\nTo test our implementation, we can fit the model for a small number of iterations and check that the calculated quantiles are consistent with those returned by qnorm() in R directly, which shows that the values match completely.\n\nfit &lt;- mod$sample(data = list(use_normal = 0), chains = 1,\n                      iter_warmup = 50, iter_sampling = 50,\n                      show_messages = FALSE,\n                      show_exceptions = FALSE)\n\nError: object 'mod' not found\n\nfit$draws(variables = c(\"log_p\", \"qnorm_test\", \"qt_test\")) |&gt;\n    posterior::mutate_variables(qnorm_true = qnorm(log_p, log.p=TRUE),\n                                qt_true = qt(log_p, df = 3, log.p=TRUE)) |&gt;\n    posterior::summarise_draws()\n\nError: object 'fit' not found\n\n\nNext, to validate the specification of gradients, we can use cmdstanrâ€™s $diagnose() method to check that our gradient calculations match those from finite-differencing, which also shows a great match:\n\nmod$diagnose(data = list(use_normal = 1))$gradients()\n\nError: object 'mod' not found\n\nmod$diagnose(data = list(use_normal = 0))$gradients()\n\nError: object 'mod' not found",
    "crumbs": [
      "Case Studies",
      "Using R's C Functions in Stan Models"
    ]
  }
]