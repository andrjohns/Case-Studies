[
  {
    "objectID": "R_C_Math.html",
    "href": "R_C_Math.html",
    "title": "Using R’s C Functions in Stan Models",
    "section": "",
    "text": "The R programming language provides robust, precise, and efficient implementations of many mathematical functions and distributions. While these can be used in Stan models by interfacing with an R session, this involves significant overhead and can result in slow sampling.\nGiven that a majority of R’s core functions and distributions are implemented in C, we can use Stan’s external C++ framework to call them directly, avoiding the need and overhead of an R session entirely."
  },
  {
    "objectID": "R_C_Math.html#motivation",
    "href": "R_C_Math.html#motivation",
    "title": "Using R’s C Functions in Stan Models",
    "section": "",
    "text": "The R programming language provides robust, precise, and efficient implementations of many mathematical functions and distributions. While these can be used in Stan models by interfacing with an R session, this involves significant overhead and can result in slow sampling.\nGiven that a majority of R’s core functions and distributions are implemented in C, we can use Stan’s external C++ framework to call them directly, avoiding the need and overhead of an R session entirely."
  },
  {
    "objectID": "R_C_Math.html#r-function-quantile-functions---log-inputs",
    "href": "R_C_Math.html#r-function-quantile-functions---log-inputs",
    "title": "Using R’s C Functions in Stan Models",
    "section": "R Function: Quantile Functions - log inputs",
    "text": "R Function: Quantile Functions - log inputs\nWhen evaluating quantile functions we often prefer to provide the input probability on the log-scale to avoid numerical issues with under- or overflow. For the present example, we will use R’s qnorm() and qt() functions to calculate the quantile function for a standard-normal distribution and a standard student-t distribution where the input probability is provided on the log scale:\nThe R signature for the qnorm() function is:\n\nqnorm(p, mean, sd, lower.tail, log.p)\n\nWhich maps directly to the underlying C implementation:\n\ndouble  qnorm(double, double, double, int, int);\n\n\nGradients\nWe will also need to calculate gradients for inputs if we are aiming to use the function with parameters in a Stan model. The gradients for quantile function, with respect to the probability parameter, are given by the reciprocal of the density, and the adjustment for inputs on the log-scale are easily given by the chain rule:\n\\[\n\\frac{\\text{d}}{\\text{d}p}F^{-1}(e^p) \\\\\n= \\frac{\\text{d}}{\\text{d}x}F^{-1}(x) \\cdot \\frac{\\text{d}}{\\text{d}p}e^p \\\\\n= \\frac{e^p}{f(F^{-1}(e^p))}\n\\]\nThis means that we can also use R’s corresponding density functions, dnorm() and dt(), to define the gradients\n\n\nStan - External C++\nTo use the density and quantile functions in our external C++, we simply include R’s math header and then define our functions as usual:\n\nheader_code &lt;- \"\n  #include &lt;stan/math.hpp&gt;\n  #include &lt;Rmath.h&gt;\n  \n  double qnorm_logp(double p, std::ostream* pstream__) {\n    return qnorm(p, 0, 1, 1, 1);\n  }\n  \n  double qt_logp(double p, double df, std::ostream* pstream__) {\n    return qt(p, df, 1, 1);\n  }\n  \n  stan::math::var qt_logp(stan::math::var p, double df, std::ostream* pstream__) {\n    return stan::math::make_callback_var(\n      qt_logp(p.val(), df, pstream__),\n      [p, df](auto& vi) mutable {\n        // Calculate gradient on log-scale for numerical stability\n        p.adj() += vi.adj() * exp(p.val() - dt(vi.val(), df, 1));\n      }\n    );\n  }\n  \n  stan::math::var qnorm_logp(stan::math::var p, std::ostream* pstream__) {\n    return stan::math::make_callback_var(\n      qnorm_logp(p.val(), pstream__),\n      [p](auto& vi) mutable {\n        // Calculate gradient on log-scale for numerical stability\n        p.adj() += vi.adj() * exp(p.val() - dnorm(vi.val(), 0, 1, 1));\n      }\n    );\n  }\n\"\n\nuser_hpp &lt;- tempfile(fileext = \".hpp\")\nwriteLines(header_code, con = user_hpp)\n\n\n\nStan - Stan Model\nWe will use the following (nonsensical) Stan model to test the values and gradients of the implementation:\n\nstan_code &lt;- \"\n  functions {\n    real qnorm_logp(real logp);\n    real qt_logp(real logp, data real df);\n  }\n  \n  data {\n    int use_normal;\n  }\n  \n  parameters {\n    real&lt;upper=0&gt; log_p;\n  }\n  \n  transformed parameters {\n    real qnorm_test = qnorm_logp(log_p);\n    real qt_test = qt_logp(log_p, 3);\n  }\n  \n  model {\n    target += use_normal ? qnorm_test : qt_test;\n  }\n\"\n\nstan_file &lt;- tempfile(fileext = \".stan\")\nwriteLines(stan_code, con = stan_file)\n\n\n\nStan - Compilation & Linking\nIn order for the Stan model to be able to use the C functions from R, we need to provide additional flags to the compilation & linking of the model. Thankfully, R has built-in functions which return these flags:\n\ncpp_options = list(\n  paste0(\"CPPFLAGS += -I\", shQuote(R.home(\"include\"))),\n  paste0(\"LDLIBS += -L\", shQuote(R.home(\"lib\")), \" -lR\")\n)\n\nWe can then pass these directly to cmdstanr, along with our model and external C++, for compilation:\n\nmod &lt;- cmdstanr::cmdstan_model(stan_file, \n                               user_header = user_hpp,\n                               stanc_options = list(\"allow-undefined\"),\n                               cpp_options = cpp_options,\n                               force_recompile = TRUE)\n\n\n\nStan - Validation\nTo test our implementation, we can fit the model for a small number of iterations and check that the calculated quantiles are consistent with those returned by qnorm() in R directly, which shows that the values match completely.\n\nfit &lt;- mod$sample(data = list(use_normal = 0), chains = 1,\n                      iter_warmup = 50, iter_sampling = 50,\n                      show_messages = FALSE,\n                      show_exceptions = FALSE)\n\nWarning: 8 of 50 (16.0%) transitions ended with a divergence.\nSee https://mc-stan.org/misc/warnings for details.\n\n\nWarning: 1 of 1 chains had an E-BFMI less than 0.3.\nSee https://mc-stan.org/misc/warnings for details.\n\nfit$draws(variables = c(\"log_p\", \"qnorm_test\", \"qt_test\")) |&gt;\n    posterior::mutate_variables(qnorm_true = qnorm(log_p, log.p=TRUE),\n                                qt_true = qt(log_p, df = 3, log.p=TRUE)) |&gt;\n    posterior::summarise_draws()\n\n# A tibble: 5 × 10\n  variable      mean   median     sd     mad     q5        q95  rhat ess_bulk\n  &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 log_p      -0.0272 -0.00127 0.0881 0.00175 -0.145 -0.0000882  1.76     1.86\n2 qnorm_test  2.86    3.02    0.855  0.789    1.12   3.75       1.76     1.86\n3 qt_test    11.4     9.42    7.62   6.06     1.39  23.2        1.76     1.86\n4 qnorm_true  2.86    3.02    0.855  0.789    1.12   3.75       1.76     1.86\n5 qt_true    11.4     9.42    7.62   6.06     1.39  23.2        1.76     1.86\n# ℹ 1 more variable: ess_tail &lt;dbl&gt;\n\n\nNext, to validate the specification of gradients, we can use cmdstanr’s $diagnose() method to check that our gradient calculations match those from finite-differencing, which also shows a great match:\n\nmod$diagnose(data = list(use_normal = 1))$gradients()\n\n  param_idx     value   model finite_diff        error\n1         0 -0.667426 0.20569     0.20569 -1.67197e-11\n\nmod$diagnose(data = list(use_normal = 0))$gradients()\n\n  param_idx      value      model finite_diff      error\n1         0 -0.0138487 -0.0867398  -0.0867398 2.9782e-11"
  }
]