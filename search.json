[
  {
    "objectID": "R_C_Math.html",
    "href": "R_C_Math.html",
    "title": "Using R’s C Functions in Stan Models",
    "section": "",
    "text": "The R programming language provides robust, precise, and efficient implementations of many mathematical functions and distributions. While these can be used in Stan models by interfacing with an R session, this involves significant overhead and can result in slow sampling.\nGiven that a majority of R’s core functions and distributions are implemented in C, we can use Stan’s external C++ framework to call them directly, avoiding the need and overhead of an R session entirely.",
    "crumbs": [
      "Case Studies",
      "Using R's C Functions in Stan Models"
    ]
  },
  {
    "objectID": "R_C_Math.html#motivation",
    "href": "R_C_Math.html#motivation",
    "title": "Using R’s C Functions in Stan Models",
    "section": "",
    "text": "The R programming language provides robust, precise, and efficient implementations of many mathematical functions and distributions. While these can be used in Stan models by interfacing with an R session, this involves significant overhead and can result in slow sampling.\nGiven that a majority of R’s core functions and distributions are implemented in C, we can use Stan’s external C++ framework to call them directly, avoiding the need and overhead of an R session entirely.",
    "crumbs": [
      "Case Studies",
      "Using R's C Functions in Stan Models"
    ]
  },
  {
    "objectID": "R_C_Math.html#r-function-quantile-functions---log-inputs",
    "href": "R_C_Math.html#r-function-quantile-functions---log-inputs",
    "title": "Using R’s C Functions in Stan Models",
    "section": "R Function: Quantile Functions - log inputs",
    "text": "R Function: Quantile Functions - log inputs\nWhen evaluating quantile functions we often prefer to provide the input probability on the log-scale to avoid numerical issues with under- or overflow. For the present example, we will use R’s qnorm() and qt() functions to calculate the quantile function for a standard-normal distribution and a standard student-t distribution where the input probability is provided on the log scale:\nThe R signature for the qnorm() function is:\n\nqnorm(p, mean, sd, lower.tail, log.p)\n\nWhich maps directly to the underlying C implementation:\n\ndouble  qnorm(double, double, double, int, int);\n\n\nGradients\nWe will also need to calculate gradients for inputs if we are aiming to use the function with parameters in a Stan model. The gradients for quantile function, with respect to the probability parameter, are given by the reciprocal of the density, and the adjustment for inputs on the log-scale are easily given by the chain rule:\n\\[\n\\frac{\\text{d}}{\\text{d}p}F^{-1}(e^p) \\\\\n= \\frac{\\text{d}}{\\text{d}x}F^{-1}(x) \\cdot \\frac{\\text{d}}{\\text{d}p}e^p \\\\\n= \\frac{e^p}{f(F^{-1}(e^p))}\n\\]\nThis means that we can also use R’s corresponding density functions, dnorm() and dt(), to define the gradients\n\n\nStan - External C++\nTo use the density and quantile functions in our external C++, we simply include R’s math header and then define our functions as usual:\n\n#include &lt;stan/math.hpp&gt;\n#include &lt;Rmath.h&gt;\n\ndouble qnorm_logp(double p, std::ostream* pstream__) {\n  return qnorm(p, 0, 1, 1, 1);\n}\n\ndouble qt_logp(double p, double df, std::ostream* pstream__) {\n  return qt(p, df, 1, 1);\n}\n\nstan::math::var qt_logp(stan::math::var p, double df, std::ostream* pstream__) {\n  return stan::math::make_callback_var(\n    qt_logp(p.val(), df, pstream__),\n    [p, df](auto& vi) mutable {\n      // Calculate gradient on log-scale for numerical stability\n      p.adj() += vi.adj() * exp(p.val() - dt(vi.val(), df, 1));\n    }\n  );\n}\n\nstan::math::var qnorm_logp(stan::math::var p, std::ostream* pstream__) {\n  return stan::math::make_callback_var(\n    qnorm_logp(p.val(), pstream__),\n    [p](auto& vi) mutable {\n      // Calculate gradient on log-scale for numerical stability\n      p.adj() += vi.adj() * exp(p.val() - dnorm(vi.val(), 0, 1, 1));\n    }\n  );\n}\n\n\n\nStan - Stan Model\nWe will use the following (nonsensical) Stan model to test the values and gradients of the implementation:\n\nfunctions {\n  real qnorm_logp(real logp);\n  real qt_logp(real logp, data real df);\n}\n\ndata {\n  int use_normal;\n}\n\nparameters {\n  real&lt;upper=0&gt; log_p;\n}\n\ntransformed parameters {\n  real qnorm_test = qnorm_logp(log_p);\n  real qt_test = qt_logp(log_p, 3);\n}\n\nmodel {\n  target += use_normal ? qnorm_test : qt_test;\n}\n\n\n\nStan - Compilation & Linking\nIn order for the Stan model to be able to use the C functions from R, we need to provide additional flags to the compilation & linking of the model. Thankfully, R has built-in functions which return these flags:\n\n# R library stored in different directory on windows\nlibdir &lt;- ifelse(.Platform$OS.type == \"windows\", R.home(\"bin\"), R.home(\"lib\"))\n\ncpp_options = list(\n  paste0(\"CPPFLAGS += -I\", shQuote(R.home(\"include\"))),\n  paste0(\"LDLIBS += -L\", shQuote(libdir), \" -lR\")\n)\n\nWe can then pass these directly to cmdstanr, along with our model and external C++, for compilation:\n\nmod &lt;- cmdstanr::cmdstan_model(stan_file,\n                               user_header = user_hpp,\n                               stanc_options = list(\"allow-undefined\"),\n                               cpp_options = cpp_options,\n                               force_recompile = TRUE)\n\nError: An error occured during compilation! See the message above for more information.\n\n\n\n\nStan - Validation\nTo test our implementation, we can fit the model for a small number of iterations and check that the calculated quantiles are consistent with those returned by qnorm() in R directly, which shows that the values match completely.\n\nfit &lt;- mod$sample(data = list(use_normal = 0), chains = 1,\n                      iter_warmup = 50, iter_sampling = 50,\n                      show_messages = FALSE,\n                      show_exceptions = FALSE)\n\nError: object 'mod' not found\n\nfit$draws(variables = c(\"log_p\", \"qnorm_test\", \"qt_test\")) |&gt;\n    posterior::mutate_variables(qnorm_true = qnorm(log_p, log.p=TRUE),\n                                qt_true = qt(log_p, df = 3, log.p=TRUE)) |&gt;\n    posterior::summarise_draws()\n\nError: object 'fit' not found\n\n\nNext, to validate the specification of gradients, we can use cmdstanr’s $diagnose() method to check that our gradient calculations match those from finite-differencing, which also shows a great match:\n\nmod$diagnose(data = list(use_normal = 1))$gradients()\n\nError: object 'mod' not found\n\nmod$diagnose(data = list(use_normal = 0))$gradients()\n\nError: object 'mod' not found",
    "crumbs": [
      "Case Studies",
      "Using R's C Functions in Stan Models"
    ]
  }
]